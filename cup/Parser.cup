// Technische Universitaet Muenchen 
// Fakultaet fuer Informatik 
// Riitta Hoellerer
//
// Praktikum des Uebersetzerbaus
// SS 2001
//
// mimasyntax.cup
// Cup specification for Mima 
//  
// CUP - LALR Parser Generator for Java
// home page: 
// /usr/proj/uebbau/CUP/
//
//
package de.brainiiiii.sqlgen;

import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;


/* Preliminaries to use the scanner.  */
scan with {: return lexer.next_token(); :};


parser code {: 
  public boolean syntaxErrors;


  Lexer lexer;

  public Parser(Lexer lex) {
    lexer = lex;
  }

  
  public void report_error(String message, Object info) {
    syntaxErrors = true;
    
    System.out.print(message);
    
    if ( !(info instanceof Symbol) ) return;
    Symbol symbol = (Symbol) info;
    
    if ( symbol.left < 0 || symbol.right < 0 ) return;
    
    System.out.println(" at line "+symbol.left+", column "+symbol.right);
  }
:}; 



/* Terminals (tokens returned by lexer). */
terminal			PACKAGE, PROJECT, DEFINE, TYPE, ENUM_DEF, TABLE; 
terminal 			SELECT_DEF;
terminal			INDICES, DATA, PRIMARY, AS;
terminal			UNIQUE, INDEX, FULLTEXT;
terminal			AUTO_ID, NULL;
terminal			NULLABLE, ID, STRING, INT, BOOL, CHAR, DOUBLE, TEXT, DATE, DATETIME, TIME, ENUM, REFERENCE;
terminal 			COMMA, EQ, DOT, SC, LBRACE, RBRACE, OPEN, CLOSE, OLBRACE, ORBRACE;
terminal Integer 	INTCONST;
terminal String  	IDENT;
terminal Boolean	BOOLCONST;
terminal String		STRINGCONST;



non terminal Project				project;
non terminal PackageDekl			package_dekl;
non terminal PackageDekl			package_path;
non terminal ColumnDekl 			column_dekl;
non terminal ColumnDeklList			column_dekl_list;
non terminal String 				optionalBracedIdent;
non terminal DefaultValue			default_value;
non terminal ColumnDeklType			column_type_dekl;
non terminal NonNullableColumnDekl 	nonnullable_column_dekl;
non terminal EnumDekl 				enum_dekl;
non terminal StringList				string_list;
non terminal StringList				ident_list;
non terminal ProjectDeklBlock		block;
non terminal ProjectDeklBlockList	blockList;
non terminal TableDekl 				tableDekl;
non terminal ColumnDeklList 		tableDekl_primary;
non terminal ColumnDeklList 		tableDekl_data;
non terminal IndexDeklList 			tableDekl_indices;
non terminal IndexDekl 				index_dekl;
non terminal IndexDeklList			index_dekl_list;
non terminal SelectDekl				selectDekl;
non terminal ColumnDeklList			optionalParamList;



terminal SQL_SELECT, SQL_FROM, SQL_WHERE, SQL_ORDER, SQL_LIMIT;
terminal SQL_ASC, SQL_DESC;

non terminal SqlSelect				sqlSelect;
non terminal SqlExpr				sqlSelect_where;
non terminal SqlSelectSourceList	sqlSelect_from;
non terminal SqlOrderElement	 	sqlSelect_order;
non terminal SqlLimit				sqlSelect_limit;
non terminal SqlSelectColumn		sqlSelectColumn;
non terminal SqlSelectColumnList	sqlSelectColumnList;
non terminal SqlExpr				sqlExpression;
non terminal SqlColumnExpr			sqlColumnExpr;
non terminal SqlSelectSourceList	sqlSelectSourceList;
non terminal SqlSelectSource		sqlSelectSource;
non terminal SqlOrderElementList 	sqlSelectOrderElementList;
non terminal SqlOrderElement	 	sqlSelectOrderElement;



project ::= 
				PROJECT IDENT:i SC package_dekl:p blockList:l
                    {: RESULT = new Project(i,p, l); :};
                    
ident_list ::=
				IDENT:e COMMA ident_list:l
					{: RESULT = l.append(e); :}
			|	IDENT:e
					{: RESULT = new StringList(e); :};

package_dekl ::= 
				PACKAGE IDENT:r package_path:p SC
					{: RESULT = new PackageDekl0(r, p); :}
			|	
					{: RESULT = new PackageDekl1(); :};

package_path ::= 
				DOT IDENT:s package_path:p
					{: RESULT = new PackageDekl0(s, p); :}
			|	 
					{: RESULT = new PackageDekl1(); :};
	
column_dekl ::=
				IDENT:s optionalBracedIdent:p AS column_type_dekl:t default_value:d
					{: RESULT = new SingleColumnDekl(s, p, t, d); :}
			|	IDENT:s OLBRACE INTCONST:l ORBRACE optionalBracedIdent:p AS column_type_dekl:t default_value:d
					{: RESULT = new ArrayColumnDekl(s, l, p, t, d); :};
					
column_dekl_list ::= 
				column_dekl_list:l COMMA column_dekl:e
					{: RESULT = l.append(e); :}
			|	column_dekl:e
					{: RESULT = new ColumnDeklList(e); :};
					
optionalParamList ::=
				LBRACE column_dekl_list:l RBRACE
					{: RESULT = l; :}
			|	LBRACE RBRACE
					{: RESULT = new ColumnDeklList(); :}
			|
					{: RESULT = new ColumnDeklList(); :};
				
optionalBracedIdent ::=
				LBRACE IDENT:s RBRACE
					{: RESULT = s; :}
			|
					{: RESULT = null; :};
					
default_value ::=
				EQ AUTO_ID
					{: RESULT = new DefaultAuto(); :}
			|	EQ NULL
					{: RESULT = new DefaultConstNull(); :}
			| 	EQ INTCONST:v
					{: RESULT = new DefaultConstInt(v); :}
			|	EQ STRINGCONST:v
					{: RESULT = new DefaultConstString(v); :}
			|	EQ BOOLCONST:v
					{: RESULT = new DefaultConstBool(v); :}
			|	
					{: RESULT = null; :};
					
column_type_dekl ::= 
				NULLABLE nonnullable_column_dekl:r
					{: RESULT = new NullableColumnDekl(r); :}
			|	nonnullable_column_dekl:r
					{: RESULT = r; :};
					
nonnullable_column_dekl ::=
				STRING LBRACE INTCONST:l RBRACE
					{: RESULT = new StringType(l); :}
			|	DATE
					{: RESULT = new DateType(); :}
			|	TIME
					{: RESULT = new TimeType(); :}
			|	DATETIME
					{: RESULT = new DateTimeType(); :}
			|	INT
					{: RESULT = new IntType(); :}
			|	BOOL
					{: RESULT = new BooleanType(); :}
			|	CHAR
					{: RESULT = new CharType(); :}
			|	TEXT
					{: RESULT = new TextType(); :}
			|	ID
					{: RESULT = new IDType(); :}
			|	DOUBLE
					{: RESULT = new DoubleType(); :}
			| 	ENUM LBRACE IDENT:s RBRACE
					{: RESULT = new EnumType(s); :}
			|	REFERENCE LBRACE IDENT:t RBRACE
					{: RESULT = new TableReferenceType(t); :}
			|	REFERENCE LBRACE IDENT:t DOT IDENT:c RBRACE
					{: RESULT = new ColumnReferenceType(t, c); :};

enum_dekl ::=
				DEFINE TYPE LBRACE ENUM_DEF RBRACE IDENT:s OPEN ident_list:o CLOSE
					{: RESULT = new EnumDekl(s, o); :};
					
string_list ::=
				string_list:l COMMA IDENT:s
					{: RESULT = l.append(s); :}
			|	IDENT:s
					{: RESULT = new StringList(s); :};
					

block ::=
				enum_dekl:d
					{: RESULT = d; :}
			|	selectDekl:d
					{: RESULT = d; :}
			|	tableDekl:d
					{: RESULT = d; :};
					
blockList ::=
				block:b blockList:l
					{: RESULT = l.append(b); :}
			|	block:b
					{: RESULT = new ProjectDeklBlockList(b); :};
					
tableDekl ::= DEFINE TABLE IDENT:n optionalBracedIdent:p OPEN tableDekl_primary:prim tableDekl_data:data tableDekl_indices:ind CLOSE
					{: RESULT = new TableDekl(n, p, prim, data, ind); :};
					
selectDekl ::= DEFINE SELECT_DEF IDENT:n optionalParamList:p OPEN sqlSelect:s CLOSE
					{: RESULT = new SelectDekl(n, p, s); :};

                    
tableDekl_primary ::=
				PRIMARY OPEN column_dekl_list:l CLOSE
					{: RESULT = l; :}
			|	
					{: RESULT = new ColumnDeklList(); :};
                    
tableDekl_data ::=
				DATA OPEN column_dekl_list:l CLOSE
					{: RESULT = l; :}
			|	
					{: RESULT = new ColumnDeklList(); :};
					
tableDekl_indices ::=
				INDICES OPEN index_dekl_list:l CLOSE
					{: RESULT = l; :}
			|
					{: RESULT = new IndexDeklList(); :};
					
index_dekl_list ::=
				index_dekl:e COMMA index_dekl_list:l
					{: RESULT = l.append(e); :}
			|	index_dekl:e
					{: RESULT = new IndexDeklList(e); :};
					
index_dekl ::=
				FULLTEXT INDEX OPEN string_list:l CLOSE
					{: RESULT = new IndexDekl(true, false, l); :}
			|	INDEX OPEN string_list:l CLOSE
					{: RESULT = new IndexDekl(false, false, l); :}
			|	FULLTEXT UNIQUE OPEN string_list:l CLOSE
					{: RESULT = new IndexDekl(true, true, l); :}
			|	UNIQUE OPEN string_list:l CLOSE
					{: RESULT = new IndexDekl(false, true, l); :};
					
					
/* SQL Definition */
sqlSelect ::=	
				SQL_SELECT sqlSelectColumnList:c sqlSelect_from:f sqlSelect_where:w sqlSelect_order:o sqlSelect_limit:l
					{: RESULT = new SqlSelect(c, f, w, o, l); :};
					
sqlSelect_from ::=
				SQL_FROM sqlSelectSourceList:l
					{: RESULT = l; :}
			|	
					{: RESULT = new SqlSelectSourceList(); :};
				
sqlSelect_where ::=
				SQL_WHERE sqlExpression:e
					{: RESULT = e; :}
			|
					{: RESULT = new SqlConstBoolExpr(true); :};

sqlSelect_limit ::= 
				SQL_LIMIT sqlExpression:o COMMA sqlExpression:l
					{: RESULT = new SqlSpecLimit(o, l); :}
			|	
					{: RESULT = new SqlNoLimit(); :};
					
sqlSelect_order ::=
				SQL_ORDER sqlSelectOrderElementList:l
					{: RESULT = l; :}
			|
					{: RESULT = new SqlSelectOrderElementList(); :};
					

				
					
					
sqlSelectColumnList ::= 
				sqlSelectColumnList:l COMMA sqlSelectColumn:c
					{: RESULT = l.append(c); :}
			|	sqlSelectColumn:c
					{: RESULT = new SqlSelectColumnList(c); :};
					
sqlSelectOrderElementList ::= 
				sqlSelectOrderElementList:l COMMA sqlSelectOrderElement:c
					{: RESULT = l.append(c); :}
			|	sqlSelectOrderElement:c
					{: RESULT = new SqlOrderElementList(c); :};
					
sqlSelectSourceList ::= 
				sqlSelectSourceList:l COMMA sqlSelectSource:c
					{: RESULT = l.append(c); :}
			|	sqlSelectSource:c
					{: RESULT = new SqlSelectSourceList(c); :};
					
sqlSelectColumn ::=
				sqlExpression:e AS IDENT:s
					{: RESULT = new SqlSelectColumn(e, s); :}
			|	sqlExpression:e
					{: RESULT = new SqlSelectColumn(e, null); :};
					
sqlSelectOrderElement ::=
				sqlColumnExpr:c SQL_ASC
					{: RESULT = new SqlSelectOrderElement(c, true); :}
			|	sqlColumnExpr:c SQL_DESC
					{: RESULT = new SqlSelectOrderElement(c, false); :};
				
sqlExpression ::=
				NULL
					{: RESULT = new SqlNullExpr(); :}
			|	sqlColumnExpr:e
					{: RESULT = e; :};

sqlSelectSource ::=
				IDENT:n AS IDENT:a
					{: RESULT = new SqlTableSelectSource(n, a, false); :};

sqlColumnExpr ::= 
				IDENT:t DOT IDENT:c
					{: RESULT = new SqlColumnExpr(t, c); :};
	
